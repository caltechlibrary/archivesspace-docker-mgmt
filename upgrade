#!/usr/bin/env bash

if [ "$(id -u)" -ne 0 ]; then
    echo "ðŸ˜µ SCRIPT MUST BE RUN AS ROOT (to modify /opt files)"
    echo "EXAMPLE: sudo ./$0 [--rebuild-solr]"
    exit 1
fi

# load environment variables from .env file
if [ -f .env ]; then
    set -a  # automatically export all variables
    # shellcheck source=/dev/null
    . ./.env
    set +a
else
    echo ".env file not found"
    exit 1
fi

# download latest archivesspace-docker release
curl -L -O "https://github.com/archivesspace/archivesspace/releases/download/${TAG}/archivesspace-docker-${TAG}.zip"
# unzip
unzip -q "archivesspace-docker-${TAG}.zip"
# remove the zip file
rm "archivesspace-docker-${TAG}.zip"

replace_config_value() {
    local KEY="$1"
    local OLD="$2"
    local NEW="$3"
    local FILE="$4"
    # helper function to run sed with proper OS-specific syntax
    run_sed() {
        local pattern="$1"
        local file="$2"
        case "$(uname)" in
            Darwin*)
                sed -i '' "$pattern" "$file"
                ;;
            *)
                sed -i "$pattern" "$file"
                ;;
        esac
    }
    if [[ "$FILE" == *.rb ]]; then
        # for ruby config files, we need to escape the key properly for regex
        # convert AppConfig[:key] to AppConfig\[:key\] for sed
        local ESCAPED_KEY
        ESCAPED_KEY=$(printf '%s\n' "$KEY" | sed 's/\[/\\[/g; s/\]/\\]/g; s/:/\\:/g')
        # escape special regex characters in OLD and NEW values
        local ESCAPED_OLD
        ESCAPED_OLD=$(printf '%s\n' "$OLD" | sed 's/[[\.*^$()+?{|]/\\&/g; s|/|\\/|g')
        local ESCAPED_NEW
        ESCAPED_NEW=$(printf '%s\n' "$NEW" | sed 's/[[\.*^$()+?{|]/\\&/g; s|/|\\/|g')
        # pattern: find lines containing the key, then substitute old with new
        local PATTERN="/${ESCAPED_KEY}/ s/${ESCAPED_OLD}/${ESCAPED_NEW}/g"
    else
        # .env file format: KEY=value
        local PATTERN="/^${KEY}=/ s|${OLD}|${NEW}|g"
    fi
    # apply the pattern
    run_sed "$PATTERN" "$FILE"
}

# replace values in the docker .env file
replace_config_value "MYSQL_DATABASE" "archivesspace" "${DB}" ".env"
# replace values in the config.rb file
replace_config_value "AppConfig[:db_url]" "archivesspace" "${DB}" "config/config.rb"
replace_config_value "AppConfig[:oai_proxy_url]" "localhost" "${DOMAIN}" "config/config.rb"
replace_config_value "AppConfig[:frontend_proxy_url]" "localhost" "${DOMAIN}" "config/config.rb"
replace_config_value "AppConfig[:public_proxy_url]" "localhost" "${DOMAIN}" "config/config.rb"

# run the restore script
./restore --upgrade
# unzip the database backup
datestamp=$(TZ=':US/Pacific' date +'%Y-%m-%d')
gunzip -k "backups/${DB}-${datestamp}.sql.gz"
# move db to the sql directory inside the archivesspace-docker directory
mv "backups/${DB}-${datestamp}.sql" "archivesspace/sql"

# rename the unzipped directory
if [ -d "archivesspace-docker-${TAG}" ]; then
    rm -rf "archivesspace-docker-${TAG}"
fi
mv archivesspace "archivesspace-docker-${TAG}"

# bring down archivesspace
cd /opt/archivesspace || exit 1
docker compose down

if [[ "$1" == "--rebuild-solr" ]]; then
    docker volume rm archivesspace_app-data archivesspace_solr-data
fi

# change back to the directory where this script is located
cd "$(dirname "${BASH_SOURCE[0]}")" || exit 1

# relink /opt/archivesspace directory
ln -sf "$(pwd)/archivesspace-docker-${TAG}" /opt/archivesspace

# bring up archivesspace
cd /opt/archivesspace || exit 1
docker compose pull
docker compose up -d --build --force-recreate

echo "ðŸŽ‰ Upgrade complete! ArchivesSpace is now running with the latest version. It may take a few minutes to become available."
